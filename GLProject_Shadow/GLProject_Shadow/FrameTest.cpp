#include "FrameTest.h"
#include <glut.h>

#include "MouseLimit.h"
#include "LinearMap.h"

#include <iostream>///////////////////////////////////
#include <list>

#include "GLPointf.h" //包含#include "GLVector3Df.h"


FrameTest::FrameTest()
{
}

FrameTest::FrameTest(int argc, char* argv[], std::string title, unsigned width, unsigned height)
:GLFramework(argc, argv, title, width, height), 
m_light0(), 
m_camera0(), 
m_keys()
{
	//pCube = new TestCube();//不能在这里创建，要么纹理ID分配失败！
}

/*不可删除的物体在Init()里创建！
* 一次性物体（子弹）在Display()里用ObjectList类创建！ */
void FrameTest::Init()
{
	GLInit m_init;

	glClearStencil(0); //设置蒙板值

	/* 添加其他初始状态 */

	float positionL[] = { 100, 400, 0, 1 }; 
	m_light0.SetLightPos(positionL);
	m_light0.TurnOnColorTrack();
	//m_light0->TurnOn(); //光照在Display中开启！

	viewAngleZ = 0;
	viewAngleY = 0;

	viewMode = 0; 

	//相机的位置
	m_camera0.UpdateFrustum();
	m_camera0.SetEyePos(0, 0, 0);
	m_camera0.SetTargetPos(0, 0, 0);
	SetCursorPos(m_WindowP->GetWidth() / 2, m_WindowP->GetHeight() / 2); //鼠标指针移至中心


	//带纹理的东西必须在这里创建，不能在构造里面创建，要么纹理ID分配会失败！
	pPlane = new TestPlane();
	pPlane->SetPos(0, 5, 0);

	pSkyBox = new SkyBox();

}

void FrameTest::Display()
{
	//glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
	glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT | GL_STENCIL_BUFFER_BIT); //模板缓冲区

	/* 灯光 */
	m_light0.TurnOn();

	/* 摄像机 */

	float viewDistance = 20; //镜头与物体之间的距离；上帝视角：拉远镜头
	if (viewMode) //第一人称
	{
		m_camera0.SetEyePos(0, 0, 0);
		m_camera0.SetViewAngleWithEyeFixed(viewAngleY, viewAngleZ);
	}
	else //上帝视角
	{
		m_camera0.SetTargetPos(0, 0, 0);
		m_camera0.SetViewAngleWithTargetFixed(viewDistance, viewAngleY, viewAngleZ);
	}
	m_camera0.UpdatePerspective(75, 1.3); //必须放在这才能启动摄像机！
	m_camera0.Apply();

	float lightPos[4];
	glGetLightfv(GL_LIGHT0, GL_POSITION, lightPos);

	GLPointf lp;
	lp.x = lightPos[0];
	lp.y = lightPos[1];
	lp.z = lightPos[2];

	//m_camera0.RenderLensFlare(lp);

	DrawScene(GL_RENDER);

	/* 其他逻辑计算 */

	glFlush();
	glutSwapBuffers();
}

/* 物体渲染 */
void FrameTest::DrawScene(GLenum mode)
{
	//灯光处绘制一个“太阳”
	float lightPos[4];
	glGetLightfv(GL_LIGHT0, GL_POSITION, lightPos);

	glPushMatrix();
	glDisable(GL_TEXTURE_2D);
	glColor3f(1, 1, 0.5);
	glTranslatef(lightPos[0], lightPos[1], lightPos[2]);
	glTranslatef(0, 20, 0);
	glutSolidSphere(5, 20, 20);
	glColor3f(1, 1, 1);
	glEnable(GL_TEXTURE_2D);
	glPopMatrix();

	
	glColor3f(1, 1, 1);
	glDisable(GL_TEXTURE_2D);
	glPushMatrix();
	glTranslatef(1, 1, 0);

	glutSolidSphere(2, 20, 20);

	glTranslatef(0, -3, 0);
	glRotatef(-90, 1.0f, 0.0f, 0.0f);
	glRotatef(60, 0.0f, 1.0f, 0.0f);

	glRectf(-10, -10, 10, 10);

	glEnable(GL_TEXTURE_2D);
	glPopMatrix();

	//飞机自动绕(20,20,0)水平飞行
	pPlane->Move(); //运动的物体需要加上这句！
	pPlane->SetRenderMode(false, true);

	pPlane->Render();
	pPlane->SetLightedFaces(lightPos);
	pPlane->RenderShadow(lightPos);

	//天空盒
	pSkyBox->SetRenderMode(false, true, TEXTURE, GL_CCW);
	pSkyBox->Render();
	pSkyBox->SetPos(0, 240, 0);

}

void FrameTest::MouseMotion(int x, int y)
{
	MouseLimit *pMouse = new MouseLimit();
	//MouseLimit mouse(m_WindowP->GetWindowHandle());//好像不是这个窗口了？

	//鼠标移动左右范围
	const int EDGE = 30;
	const int limitLeft = EDGE;
	const int limitRight = m_WindowP->GetWidth() - EDGE;

	pMouse->MouseMovLimitRL(limitLeft, limitRight);

	//从窗口中鼠标的位置映射到离窗口中心的角度rotY(左右)、rotZ(上下)
	pMouse->PosIntoAngleY(limitLeft, limitRight, 180, -180);
	pMouse->PosIntoAngleZ(m_WindowP->GetHeight(), 0, -90, 90);

	viewAngleY = pMouse->GetMapAngleY(x);
	viewAngleZ = pMouse->GetMapAngleZ(y);
}

void FrameTest::MousePassiveMotion(int x, int y)
{
	MouseMotion(x, y);
}

void FrameTest::MouseButton(int button, int state, int x, int y)
{
	if (GLUT_LEFT_BUTTON == button)
	{
		if (GLUT_DOWN == state)
		{
			/*按下鼠标左键*/
			std::cout << "按下鼠标左键" << std::endl;	
		}
		else
		{
			/*松开鼠标左键*/
			std::cout << "松开鼠标左键" << std::endl;
		}
	}
	if (GLUT_RIGHT_BUTTON == button)
	{
		if (GLUT_DOWN == state)
		{
			/*按下鼠标左键*/
			std::cout << "按下鼠标右键" << std::endl;
		}
		else
		{
			/*松开鼠标左键*/
			std::cout << "松开鼠标右键" << std::endl;
		}
	}
}

void FrameTest::KeyboardSet(unsigned char key, int x, int y)//设定函数
{
	m_keys.SetPressed(key);
	if (key == ' ') //放在这里切换视角才不会被一直检测！
		viewMode = !viewMode;
}

void FrameTest::KeyboardUpSet(unsigned char key, int x, int y)
{
	m_keys.SetReleased(key);
}

void FrameTest::KeyboardRespond()//在Timer里调用响应函数
{
	if (m_keys.IsPressed('w'))
	{
		std::cout << "W按下" << std::endl;
	}

	if (m_keys.IsPressed('s'))
	{
		std::cout << "S按下" << std::endl;
	}

	if (m_keys.IsPressed('a'))
	{
		std::cout << "A按下" << std::endl;
	}

	if (m_keys.IsPressed('d'))
	{
		std::cout << "D按下" << std::endl;
	}

}

void FrameTest::SpecialKey(int key, int x, int y)
{
	if (key == GLUT_KEY_F1)
	{
		std::cout << "F1全屏模式。" << std::endl;
		//Reshape(1024, 768);
	}
	if (key == GLUT_KEY_F2)
	{
		exit(0);
	}
}
